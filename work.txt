diff --git a/.gitignore b/.gitignore
index 5db435c..2a2f18d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -147,3 +147,6 @@ test-vault/*/*.md
 main.js
 
 styles.css
+
+# ai agents
+.claude
diff --git a/src/ChatService.ts b/src/ChatService.ts
index 15cfbae..78ee7a5 100644
--- a/src/ChatService.ts
+++ b/src/ChatService.ts
@@ -13,7 +13,7 @@ interface ActiveStreamInfo {
 export class ChatService {
     private plugin: Plugin;
     private openRouterService: OpenRouterService;
-    private activeStreams: Map<string, ActiveStreamInfo> = new Map(); // Key: note path
+    private activeStreams: Map<string, ActiveStreamInfo> = new Map();
 
     constructor(plugin: Plugin, openRouterService: OpenRouterService) {
         this.plugin = plugin;
@@ -21,21 +21,15 @@ export class ChatService {
     }
 
     /**
-     * Parses note content into ChatMessages, excluding content at or after a given position.
-     * @param fullContent The raw string content of the note.
-     * @param separator The separator used to divide messages.
-     * @param parseUntilPos The position in the editor up to which content should be parsed.
-     * @returns An array of ChatMessage objects.
+     * Parses note content into ChatMessages up to a given position, respecting boundary markers.
      */
     private parseNoteContent(fullContent: string, separator: string, parseUntilOffset: number): ChatMessage[] {
-        const relevantContent = fullContent.substring(0, parseUntilOffset); // Content before the insertion point
+        const relevantContent = fullContent.substring(0, parseUntilOffset);
 
-        // Regex to find the marker on its own line, allowing whitespace
-        // Needs to escape potential regex characters in the marker itself
+        // Find boundary marker (^^^) - content above this marker is ignored during parsing
         const escapedMarker = CHAT_BOUNDARY_MARKER.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
         const boundaryRegex = new RegExp('(?:^|\\n)\\s*' + escapedMarker + '\\s*(?=\\n|$)', 'g');
 
-        // Find the *last* occurrence of the marker pattern within the relevant content
         let lastMatch: RegExpExecArray | null = null;
         let currentMatch: RegExpExecArray | null;
         while ((currentMatch = boundaryRegex.exec(relevantContent)) !== null) {
@@ -44,20 +38,18 @@ export class ChatService {
 
         let contentToParse: string;
         if (lastMatch) {
-            // If marker found, parse only the content *after* the full match
             const startIndex = lastMatch.index + lastMatch[0].length;
             contentToParse = relevantContent.substring(startIndex);
             log.debug(`Found last chat boundary marker "${CHAT_BOUNDARY_MARKER}" ending at index ${startIndex -1}. Parsing content after marker up to offset ${parseUntilOffset}.`);
         } else {
-            // If no marker found, parse all relevant content
             contentToParse = relevantContent;
         }
 
-        // Proceed with splitting the correctly selected content
         const parts = contentToParse.split(separator)
                                     .map(part => part.trim())
                                     .filter(part => part.length > 0);
 
+        // Messages alternate user -> assistant -> user based on separator splits
         const messages: ChatMessage[] = [];
         let currentRole: 'user' | 'assistant' = 'user';
 
@@ -73,20 +65,17 @@ export class ChatService {
     }
 
     /**
-     * Inserts text at a given position, ensuring it starts on a new line if necessary.
-     * @returns A tuple containing the start and end positions of the inserted text.
+     * Inserts text ensuring proper line boundaries for chat messages.
+     * @returns Start and end positions of the inserted text.
      */
     private insertTextAtPos(editor: Editor, text: string, pos: EditorPosition): [EditorPosition, EditorPosition] {
         const currentOffset = editor.posToOffset(pos);
         const docValue = editor.getValue();
         let textToInsert = text;
 
-        // Ensure the text starts on a new line unless it's at the very beginning
-        // or the preceding character is already a newline.
         if (currentOffset > 0 && docValue[currentOffset - 1] !== '\n') {
             textToInsert = '\n' + textToInsert;
         }
-        // Ensure it ends with a newline
         if (!textToInsert.endsWith('\n')) {
              textToInsert += '\n';
         }
@@ -104,11 +93,8 @@ export class ChatService {
 
 
     /**
-     * Handles the unified chat process. Inserts a status message, calls API, streams response.
-     * @param editor The editor instance.
-     * @param file The file associated with the editor.
-     * @param settings The current plugin settings.
-     * @param insertionPos The position in the editor where the chat should be initiated (e.g., cursor).
+     * Orchestrates the complete chat flow: status message, API call, streaming response.
+     * Handles streaming lifecycle, cancellation, and proper message formatting.
      */
     async startChat(
         editor: Editor,
@@ -124,24 +110,23 @@ export class ChatService {
             return;
         }
 
-        // 1. Insert Status Message
         const statusMessage = `Calling ${settings.defaultModel}...`;
         const [actualStatusStartPos, actualStatusEndPos] = this.insertTextAtPos(editor, statusMessage, insertionPos);
         log.debug(`Inserted status message from [${actualStatusStartPos.line}, ${actualStatusStartPos.ch}] to [${actualStatusEndPos.line}, ${actualStatusEndPos.ch}]`);
-        editor.setCursor(actualStatusEndPos); // Move cursor after status message
+        editor.setCursor(actualStatusEndPos);
 
-        // 2. Parse Content *before* the status message
+        // Parse content before the status message to build conversation history
         const parseUntilOffset = editor.posToOffset(actualStatusStartPos);
         const messages = this.parseNoteContent(editor.getValue(), settings.chatSeparator, parseUntilOffset);
 
         if (messages.length === 0) {
             new Notice('No content found before the chat initiation point.');
             this.removeStatusMessageAtPos(editor, settings, actualStatusStartPos, actualStatusEndPos, 'No content found.');
-            editor.setCursor(actualStatusStartPos); // Move cursor back
+            editor.setCursor(actualStatusStartPos);
             return;
         }
 
-        // 3. Set up AbortController and track stream
+        // Track stream for cancellation and cleanup
         const abortController = new AbortController();
         this.activeStreams.set(notePath, {
             controller: abortController,
@@ -150,11 +135,10 @@ export class ChatService {
         });
 
         let isFirstChunk = true;
-        let currentInsertPos: EditorPosition | null = null; // Position where the next chunk should be inserted
-        let lastPosition: EditorPosition | null = null; // Tracks the end of the last inserted chunk
+        let currentInsertPos: EditorPosition | null = null;
+        let lastPosition: EditorPosition | null = null;
 
         try {
-            // 4. Call API and Stream Response
             const streamGenerator = this.openRouterService.streamChatCompletion(
                 messages,
                 settings,
@@ -164,25 +148,22 @@ export class ChatService {
             for await (const chunk of streamGenerator) {
                 if (chunk) {
                     if (isFirstChunk) {
-                        // 4a. Remove status message
+                        // Replace status message with separator and start streaming response
                         this.removeStatusMessageAtPos(editor, settings,
                             actualStatusStartPos, actualStatusEndPos, 'First chunk received.');
 
-                        // 4b. Insert separator with normalized spacing
                         currentInsertPos = this.insertSeparatorWithSpacing(
                             editor,
-                            actualStatusStartPos, // Insert where status message was
+                            actualStatusStartPos,
                             settings.chatSeparator
                         );
 
-                        // 4c. Insert the first chunk
                         editor.replaceRange(chunk, currentInsertPos, currentInsertPos);
                         lastPosition = editor.offsetToPos(
                             editor.posToOffset(currentInsertPos) + chunk.length
                         );
                         isFirstChunk = false;
                     } else {
-                        // 4d. Insert subsequent chunks
                         if (!lastPosition) {
                             throw new Error("Internal state error: lastPosition not set after first chunk.");
                         }
@@ -193,21 +174,19 @@ export class ChatService {
                     }
 
                 }
-            } // End for await loop
+            }
 
-            // 5. Handle Stream Completion
-            if (!isFirstChunk && lastPosition) { // Ensure stream actually inserted content
-                // Append final separator and position cursor
+            // Handle stream completion - add final separator and position cursor
+            if (!isFirstChunk && lastPosition) {
                 lastPosition = this.insertSeparatorWithSpacing(
                     editor,
                     lastPosition,
                     settings.chatSeparator
                 );
-                editor.setCursor(lastPosition); // Set cursor after the separator
+                editor.setCursor(lastPosition);
             } else if (isFirstChunk) {
-                // No chunks received - status message should still be there
                 this.removeStatusMessageAtPos(editor, settings, actualStatusStartPos, actualStatusEndPos, 'Stream ended with no content.');
-                editor.setCursor(actualStatusStartPos); // Move cursor back to where status was
+                editor.setCursor(actualStatusStartPos);
                 new Notice("Chat completed with no response.");
             } else if (lastPosition) {
                  log.warn("Stream finished, content likely received, placing cursor at end of content.");
@@ -217,7 +196,6 @@ export class ChatService {
                  editor.setCursor(actualStatusStartPos);
             }
         } catch (error: any) {
-            // 6. Handle Errors
             log.error('Error during chat stream orchestration:', error);
             let reason = 'Unknown stream error';
             let noticeMessage = 'Chat error: Unknown error';
@@ -238,17 +216,14 @@ export class ChatService {
             }
             new Notice(noticeMessage);
 
-            // If the error occurred before the first chunk, status message should still be present
             if (isFirstChunk) {
                 log.debug("Error occurred before first chunk, attempting status message cleanup.");
                 this.removeStatusMessageAtPos(editor, settings, actualStatusStartPos, actualStatusEndPos, `Error/Cancel occurred: ${reason}`);
-                editor.setCursor(actualStatusStartPos); // Move cursor back
+                editor.setCursor(actualStatusStartPos);
             } else {
                  log.debug("Error occurred after first chunk, status message should already be removed.");
-                 // Cursor might be somewhere in the partially inserted response
             }
         } finally {
-            // 7. Final Cleanup
             this.activeStreams.delete(notePath);
             log.debug(`Removed active stream tracker for note: ${notePath}`);
         }
@@ -256,13 +231,7 @@ export class ChatService {
 
 
     /**
-     * Attempts to remove the status message inserted by startChat.
-     * @param editor The editor instance.
-     * @param settings Plugin settings to get the model name.
-     * @param startPos The expected start position of the status message.
-     * @param endPos The expected end position of the status message.
-     * @param reason Optional reason for removal logging.
-     * @returns True if the message was found and removed, false otherwise.
+     * Removes the temporary status message, with validation to ensure we're removing the right content.
      */
     private removeStatusMessageAtPos(editor: Editor, settings: PluginSettings, startPos: EditorPosition | undefined, endPos: EditorPosition | undefined, reason?: string): boolean {
         if (!startPos || !endPos) {
@@ -274,13 +243,12 @@ export class ChatService {
         let removed = false;
 
         try {
-            // Check range validity before getting text
              if (editor.posToOffset(startPos) >= editor.posToOffset(endPos)) {
                  log.warn("Invalid range for status message removal (start >= end).", { start: startPos, end: endPos, reason });
                  return false;
              }
 
-            const currentText = editor.getRange(startPos, endPos).trim(); // Trim to handle potential extra newlines from insertTextAtPos
+            const currentText = editor.getRange(startPos, endPos).trim();
 
             if (currentText === expectedStatusBase) {
                 editor.replaceRange('', startPos, endPos);
@@ -296,8 +264,7 @@ export class ChatService {
     }
 
     /**
-     * Inserts the separator with appropriate spacing.
-     * @returns The position right after the inserted block.
+     * Inserts chat separator with proper newline spacing based on context.
      */
     private insertSeparatorWithSpacing(
         editor: Editor,
@@ -308,13 +275,12 @@ export class ChatService {
         const docLength = editor.getValue().length;
         const originalValue = editor.getValue();
 
-        // Adjust position to be *after* any existing newlines at the target pos
         while (currentOffset < docLength && originalValue[currentOffset] === '\n') {
             currentOffset++;
         }
         const adjustedPos = editor.offsetToPos(currentOffset);
 
-        // Determine prefix: Need two newlines unless at start or preceded by newline.
+        // Determine spacing: need proper newlines for separator isolation
         let prefix = '\n\n';
         if (currentOffset === 0) {
             prefix = '';
@@ -322,26 +288,18 @@ export class ChatService {
              prefix = '\n';
         }
 
-        const suffix = '\n\n'; // Always need two newlines after
+        const suffix = '\n\n';
         const block = `${prefix}${separator}${suffix}`;
 
         editor.replaceRange(block, adjustedPos, adjustedPos);
-
-        // Return the position *after* the entire inserted block
         return editor.offsetToPos(currentOffset + block.length);
     }
 
 
-    /**
-     * Checks if a stream is currently active for the given file path.
-     */
     isStreamActive(filePath: string): boolean {
         return this.activeStreams.has(filePath);
     }
 
-    /**
-     * Cancels an active chat stream.
-     */
     cancelStream(filePath: string, editor: Editor, settings: PluginSettings): boolean {
         const streamInfo = this.activeStreams.get(filePath);
         if (streamInfo) {
@@ -349,14 +307,13 @@ export class ChatService {
             const reason = "Chat cancelled by user action.";
             streamInfo.controller.abort(reason);
 
-            // Attempt status message cleanup using stored positions
             log.debug(`Attempting status message cleanup for cancelled stream: ${filePath}`);
             const removed = this.removeStatusMessageAtPos(editor, settings, streamInfo.statusStartPos, streamInfo.statusEndPos, reason);
             if (removed) {
-                 editor.setCursor(streamInfo.statusStartPos); // Move cursor back if status was removed
+                 editor.setCursor(streamInfo.statusStartPos);
             }
 
-            this.activeStreams.delete(filePath); // Ensure removal
+            this.activeStreams.delete(filePath);
             log.debug(`Stream cancelled and removed from active streams for: ${filePath}`);
             new Notice(reason);
             return true;
diff --git a/src/EditorHandler.ts b/src/EditorHandler.ts
index e02f7f6..a2751dc 100644
--- a/src/EditorHandler.ts
+++ b/src/EditorHandler.ts
@@ -14,8 +14,7 @@ export class EditorHandler {
 	}
 
 	/**
-	 * Sets cursor position after command execution - either at the end of the previous line
-	 * or at document start if command was on the first line.
+	 * Positions cursor to end of previous line or start of document after command removal.
 	 */
 	private _setCursorBeforeCommand(editor: Editor, commandLineIndex: number): void {
 		if (commandLineIndex > 0) {
@@ -23,14 +22,13 @@ export class EditorHandler {
 			const targetLineLength = editor.getLine(targetLineIndex).length;
 			editor.setCursor({ line: targetLineIndex, ch: targetLineLength });
 		} else {
-			// If command was on the very first line (index 0), move cursor to start
 			editor.setCursor({ line: 0, ch: 0 });
 		}
 	}
 
 	/**
-		* Handles chat command activation.
-		* Replaces command line with status message and initiates chat.
+	 * Processes chat command trigger by removing command line and initiating streaming response.
+	 * Command line is completely removed before starting chat to avoid content duplication.
 	 */
 	public triggerChatCommand(
 		editor: Editor,
@@ -45,39 +43,32 @@ export class EditorHandler {
 			return;
 		}
 
-		// I think we should rename this to CommandPhraseStartPos etcc.
 		const commandLineStartPos: EditorPosition = { line: commandLineIndex, ch: 0 };
 		const commandLineEndPos: EditorPosition = { line: commandLineIndex, ch: editor.getLine(commandLineIndex).length };
 
-		// Handle line endings appropriately based on position in document
+		// Include newline for mid-document lines to prevent line merging
 		const rangeToRemoveEnd = (commandLineIndex < editor.lastLine())
-			? { line: commandLineIndex + 1, ch: 0 } // Include newline if not last line
-			: commandLineEndPos; // Just the line content if last line
+			? { line: commandLineIndex + 1, ch: 0 }
+			: commandLineEndPos;
 
-		// Remove the command phrase
 		editor.replaceRange('', commandLineStartPos, rangeToRemoveEnd);
 
-		// Position cursor for incoming stream
-		// editor.setCursor(statusMessageEndPos);
-
-		// Start chat, providing the position where the status message started
+		// Start chat at removed command position for streaming response
 		this.plugin.chatService.startChat(
 			editor,
 			file,
 			settings,
-			commandLineStartPos // Position where status message was inserted
-		).catch((error: Error) => { // Add type to error
+			commandLineStartPos
+		).catch((error: Error) => {
 			log.error("Error starting chat from command phrase:", error);
 			const errorMessage = error instanceof Error ? error.message : 'Unknown error';
-			// Log the error. startChat handles cleanup and user notification.
 			log.error(`Chat Error from command phrase: ${errorMessage}. Relying on startChat cleanup.`);
-			// No need for fallback insertion here, startChat handles its errors internally.
 		});
 	}
 
 	/**
-	 * Handles archive command activation.
-	 * Removes command line and moves file to archive location.
+	 * Processes archive command by removing command line and moving file to archive.
+	 * Shows early notice for LLM-powered rename operations due to potential delay.
 	 */
 	public triggerArchiveCommand(
 		editor: Editor,
@@ -92,26 +83,23 @@ export class EditorHandler {
 			return;
 		}
 
-		// Define the range for the command line itself
 		const commandLineStartPos: EditorPosition = { line: commandLineIndex, ch: 0 };
 		const commandLineEndPos: EditorPosition = { line: commandLineIndex, ch: editor.getLine(commandLineIndex).length };
 
-		// Determine the end of the range to remove (command line + its newline, or just command line if last line)
 		const rangeToRemoveEnd = (commandLineIndex < editor.lastLine())
-			? { line: commandLineIndex + 1, ch: 0 } // Remove the line and its newline
-			: commandLineEndPos; // Just remove the content if it's the last line
+			? { line: commandLineIndex + 1, ch: 0 }
+			: commandLineEndPos;
 
-		// Remove the command line (and its newline if applicable)
 		editor.replaceRange('', commandLineStartPos, rangeToRemoveEnd);
 
-		// Set cursor position *before* the async operation
+		// Position cursor before async operation to provide immediate feedback
 		this._setCursorBeforeCommand(editor, commandLineIndex);
 
-		// Show status *before* calling the potentially slow archive function if using model
+		// Notify user early if LLM rename is enabled due to potential processing delay
 		if (settings.enableArchiveRenameLlm) {
 			const titleModel = settings.llmRenameModel || settings.defaultModel;
 			if (titleModel && settings.apiKey) {
-				new Notice(`Calling ${titleModel} to generate title...`, 5000); // Temporary notice
+				new Notice(`Calling ${titleModel} to generate title...`, 5000);
 			} else {
 				log.warn("Archive rename with LLM enabled, but API key or model not set. Skipping notice.");
 			}
@@ -123,20 +111,16 @@ export class EditorHandler {
 					file,
 					settings.archiveFolderName,
 					settings,
-					editor // Pass the editor instance
+					editor
 				);
 				if (newPath) {
-					// Parse new name and folder from the returned path
-					const newName = newPath.split('/').pop() || file.basename; // Fallback to original basename
-					const archiveFolder = settings.archiveFolderName; // Use the setting value
-
-					// Show persistent notice
+					const newName = newPath.split('/').pop() || file.basename;
+					const archiveFolder = settings.archiveFolderName;
 					new Notice(`Renamed to ${newName}\nMoved to ${archiveFolder}`);
 
 				} else {
 					new Notice("Failed to archive note.");
 					log.warn("FileSystemService.moveFileToArchive returned null.");
-					// Consider adding back the command line if archive fails? Might be complex.
 				}
 			} catch (error) {
 				console.error("Error during note archive:", error);
@@ -146,8 +130,7 @@ export class EditorHandler {
 	}
 
 	/**
-	 * Handles new chat command activation.
-	 * Removes command line and creates a new chat note.
+	 * Processes new chat command by removing command line and executing note creation command.
 	 */
 	public triggerNewChatCommand(
 		editor: Editor,
@@ -155,30 +138,26 @@ export class EditorHandler {
 		settings: PluginSettings,
 		commandLineIndex: number
 	): void {
-		// Define the range for the command line itself
 		const commandLineStartPos: EditorPosition = { line: commandLineIndex, ch: 0 };
 		const commandLineEndPos: EditorPosition = { line: commandLineIndex, ch: editor.getLine(commandLineIndex).length };
 
-		// Determine the end of the range to remove (command line + its newline, or just command line if last line)
 		const rangeToRemoveEnd = (commandLineIndex < editor.lastLine())
-			? { line: commandLineIndex + 1, ch: 0 } // Remove the line and its newline
-			: commandLineEndPos; // Just remove the content if it's the last line
+			? { line: commandLineIndex + 1, ch: 0 }
+			: commandLineEndPos;
 
-		// Remove the command line (and its newline if applicable)
 		editor.replaceRange('', commandLineStartPos, rangeToRemoveEnd);
 
-		// Set cursor position *before* executing the command
+		// Position cursor before command execution to maintain proper state
 		this._setCursorBeforeCommand(editor, commandLineIndex);
 
-		// Execute the command *after* modifying the editor
+		// Execute note creation after editor modification to ensure clean state
 		// @ts-ignore - Assuming 'commands' exists on app
 		this.app.commands.executeCommandById('simple-note-chat:create-new-chat-note');
 		new Notice("Creating new chat note...");
 	}
 
 	/**
-	 * Handles model selection command activation.
-	 * Removes command line and opens the model selector modal.
+	 * Processes model selection command by removing command line and opening model selector.
 	 */
 	public triggerModelCommand(
 		editor: Editor,
@@ -186,30 +165,25 @@ export class EditorHandler {
 		settings: PluginSettings,
 		commandLineIndex: number
 	): void {
-		// Define the range for the command line itself
 		const commandLineStartPos: EditorPosition = { line: commandLineIndex, ch: 0 };
 		const commandLineEndPos: EditorPosition = { line: commandLineIndex, ch: editor.getLine(commandLineIndex).length };
 
-		// Determine the end of the range to remove (command line + its newline, or just command line if last line)
 		const rangeToRemoveEnd = (commandLineIndex < editor.lastLine())
-			? { line: commandLineIndex + 1, ch: 0 } // Remove the line and its newline
-			: commandLineEndPos; // Just remove the content if it's the last line
+			? { line: commandLineIndex + 1, ch: 0 }
+			: commandLineEndPos;
 
-		// Remove the command line (and its newline if applicable)
 		editor.replaceRange('', commandLineStartPos, rangeToRemoveEnd);
 
-		// Set cursor position *before* opening the modal
+		// Position cursor before modal to maintain editor state
 		this._setCursorBeforeCommand(editor, commandLineIndex);
 
-		// Open the modal
 		new ModelSelectorModal(this.plugin).open();
 		log.debug(`Executed model command ('${settings.modelCommandPhrase}') on line ${commandLineIndex}. Opening modal.`);
 	}
 
 	/**
-		* Opens the model selector modal directly.
-		* Intended for use by commands/hotkeys.
-		*/
+	 * Opens model selector modal via command/hotkey (bypasses command line processing).
+	 */
 	public openModelSelectorModal(): void {
 		new ModelSelectorModal(this.plugin).open();
 		log.debug("Opened model selector modal via command/hotkey.");
diff --git a/src/FileSystemService.ts b/src/FileSystemService.ts
index a11c6aa..5325b5c 100644
--- a/src/FileSystemService.ts
+++ b/src/FileSystemService.ts
@@ -14,39 +14,31 @@ export class FileSystemService {
     }
 
     /**
-     * Moves a file to an archive folder, handling name conflicts.
-     * @param file The file to move.
-     * @param archiveFolderName The relative path of the archive folder from the vault root.
-     * @param settings The plugin settings containing archive and LLM options.
-     * @param editor Optional Editor instance if the file is currently active in an editor.
-     * @returns The new path of the archived file, or null if an error occurred.
+     * Moves file to archive folder with optional LLM title generation and boundary marker handling.
+     * 
+     * Boundary marker (^^^) system: If present, content above marker stays in original file,
+     * content below marker gets archived. This allows keeping conversation context while
+     * archiving completed chat sessions.
      */
     async moveFileToArchive(file: TFile, archiveFolderName: string, settings: PluginSettings, editor?: Editor): Promise<string | null> {
         try {
             const originalContent = await this.app.vault.read(file);
 
-            // Needs to escape potential regex characters in the marker itself
             const escapedMarker = CHAT_BOUNDARY_MARKER.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
-            log.debug(`escapedMarker: ${escapedMarker}`);
             const boundaryRegex = new RegExp(`^\\s?${escapedMarker}\\s*$`, 'm');
-            log.debug(`boundaryRegex: ${boundaryRegex}`);
 
             const markerExists = boundaryRegex.test(originalContent);
 
             let contentForTitleGeneration = originalContent;
             let contentToArchive = originalContent;
-            let contentAboveMarker = ''; // Only used if marker exists
+            let contentAboveMarker = '';
 
             if (markerExists) {
                 const parts = originalContent.split(boundaryRegex);
                 contentAboveMarker = parts[0];
-                log.debug(`contentAboveMarker: ${contentAboveMarker}`);
-                // In case the marker appears multiple times, we archive everything after the first one.
+                // Handle multiple markers by archiving everything after the first one
                 contentToArchive = parts.slice(1).join(CHAT_BOUNDARY_MARKER).trimStart();
-                contentForTitleGeneration = contentToArchive; // Use archived part for title
-                log.debug(`Marker found. Archiving content below marker. Original file will retain content above.`);
-            } else {
-                log.debug(`Marker not found. Archiving entire file.`);
+                contentForTitleGeneration = contentToArchive;
             }
 
 
@@ -56,10 +48,9 @@ export class FileSystemService {
             if (!folderExists) {
                 try {
                     await this.app.vault.createFolder(normalizedArchivePath);
-                    log.debug(`Created archive folder: ${normalizedArchivePath}`);
                 } catch (error) {
                     log.error(`Failed to create archive folder "${normalizedArchivePath}":`, error);
-                    return null; // Cannot proceed without the folder
+                    return null;
                 }
             }
 
@@ -74,7 +65,6 @@ export class FileSystemService {
             }
 
             if (settings.enableArchiveRenameLlm) {
-                // Use the determined content (either full or below marker) for title generation
                 const content = contentForTitleGeneration;
                 const titleModel = settings.llmRenameModel || settings.defaultModel;
 
@@ -90,42 +80,34 @@ export class FileSystemService {
                     const prompt = `Create a concise functional title for the following note content, under ${wordLimit} words.${settings.llmRenameIncludeEmojis ? ' You can include relevant emojis.' : ''} Respond ONLY with the title itself, no explanations or quotation marks. Note Content:\n\n${content}`;
                     const messages: ChatMessage[] = [{ role: 'user', content: prompt }];
 
-                    log.debug(`FileSystemService: Requesting LLM title with model ${titleModel}`);
                     const llmTitle = await this.openRouterService.getChatCompletion(
                         settings.apiKey,
                         titleModel,
                         messages,
-                        wordLimit * 5 // Estimate max tokens based on word limit
+                        wordLimit * 5
                     );
 
                     if (llmTitle) {
-                        log.debug(`FileSystemService: Received LLM title: "${llmTitle}"`);
-                        // Whitelist approach for sanitization
+                        // Sanitize LLM-generated title for filesystem safety using whitelist approach
                         const basicWhitelistRegex = /[^a-zA-Z0-9 ]/g;
-                        // Regex to keep alphanumeric characters, spaces, and common emoji ranges (requires 'u' flag)
                         const emojiWhitelistRegex = /[^a-zA-Z0-9 \u{1F300}-\u{1F5FF}\u{1F600}-\u{1F64F}\u{1F680}-\u{1F6FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{FE00}-\u{FE0F}\u{1F900}-\u{1F9FF}\u{1FA70}-\u{1FAFF}]/gu;
 
-                        let sanitizedTitle = llmTitle; // Start with the raw title
-
-                        // Apply the appropriate whitelist regex based on settings
+                        let sanitizedTitle = llmTitle;
                         if (settings.llmRenameIncludeEmojis) {
                             sanitizedTitle = sanitizedTitle.replace(emojiWhitelistRegex, '');
-                            log.debug(`Sanitizing with emoji whitelist. Before: "${llmTitle}", After: "${sanitizedTitle}"`);
                         } else {
                             sanitizedTitle = sanitizedTitle.replace(basicWhitelistRegex, '');
-                             log.debug(`Sanitizing with basic whitelist. Before: "${llmTitle}", After: "${sanitizedTitle}"`);
                         }
 
-                        // Continue with existing post-processing
                         sanitizedTitle = sanitizedTitle
-                            .trim()                         // Trim leading/trailing whitespace
-                            .replace(/\s+/g, ' ')           // Collapse multiple spaces to one
-                            .substring(0, 100);             // Limit length
+                            .trim()
+                            .replace(/\s+/g, ' ')
+                            .substring(0, 100);
 
                         if (sanitizedTitle) {
                             const titleCasedSanitizedTitle = sanitizedTitle
                                 .split(' ')
-                                .map(word => word ? word.charAt(0).toUpperCase() + word.slice(1) : '') // Handle potential empty strings from split
+                                .map(word => word ? word.charAt(0).toUpperCase() + word.slice(1) : '')
                                 .join(' ');
 
                             const filenameWithoutExt = baseFilename.substring(0, baseFilename.lastIndexOf('.'));
@@ -134,7 +116,6 @@ export class FileSystemService {
                             } else {
                                 baseFilename = `${titleCasedSanitizedTitle}${originalExtension}`;
                             }
-                            log.debug(`FileSystemService: Updated baseFilename with LLM title: ${baseFilename}`);
                         } else {
                              log.warn(`FileSystemService: LLM title "${llmTitle}" became empty after sanitization.`);
                              new Notice("LLM title was empty after sanitization. Archiving with current name.");
@@ -148,27 +129,21 @@ export class FileSystemService {
 
             let targetPath = normalizePath(`${normalizedArchivePath}/${baseFilename}`);
             targetPath = await this.findAvailablePath(normalizedArchivePath, baseFilename);
-            // Check if the boundary marker was present, if so we'll keep the content above the marker
-            // and only save content below it to the archived note
+            
             if (markerExists) {
+                // Create archive with content below marker, keep content above marker in original
                 await this.app.vault.create(targetPath, contentToArchive);
-                log.debug(`Created archive file at ${targetPath} with content below marker.`);
-                // Modify original file to keep content above marker
+                
                 if (editor) {
                     editor.setValue(contentAboveMarker);
-                    // Position cursor at the very end of the document
                     editor.setCursor(editor.lastLine());
-                    log.debug(`Modified original file ${file.path} using Editor API to retain content above marker.`);
-                } else { // No editor instance
+                } else {
                     await this.app.vault.process(file, (_data) => contentAboveMarker);
-                    log.debug(`Modified original file ${file.path} using Vault.process to retain content above marker.`);
                 }
             } else {
-                // move the entire file to the archive
                 await this.app.fileManager.renameFile(file, targetPath);
-                log.debug(`Archived entire file ${file.path} to ${targetPath}`);
             }
-            return targetPath; // Return the path of the archived content
+            return targetPath;
 
         } catch (error) {
             log.error(`Error archiving file "${file.path}" to folder "${archiveFolderName}":`, error);
@@ -177,10 +152,8 @@ export class FileSystemService {
     }
 
     /**
-     * Finds an available file path in a folder by appending a number if the base name exists.
-     * @param folderPath The normalized path of the target folder.
-     * @param baseFilename The desired filename (including extension).
-     * @returns A promise that resolves to an available, normalized full path.
+     * Handles file naming collisions by appending a counter to find an available path.
+     * Essential for preventing overwrites when multiple files have similar generated titles.
      */
     public async findAvailablePath(folderPath: string, baseFilename: string): Promise<string> {
         let targetPath = normalizePath(`${folderPath}/${baseFilename}`);
@@ -199,15 +172,12 @@ export class FileSystemService {
 
     /**
      * Deletes a file by moving it to the system trash.
-     * @param file The file to delete.
      */
     async deleteFile(file: TFile): Promise<void> {
         try {
             await this.app.vault.trash(file, true);
-            log.debug(`Moved file ${file.path} to system trash`);
         } catch (error) {
             log.error(`Error deleting file "${file.path}":`, error);
-            // Error is logged but not re-thrown
         }
     }
 }
diff --git a/src/ModelSelectorModal.ts b/src/ModelSelectorModal.ts
index 62e6c31..a0b4aef 100644
--- a/src/ModelSelectorModal.ts
+++ b/src/ModelSelectorModal.ts
@@ -21,7 +21,7 @@ export class ModelSelectorModal extends Modal {
 			text: 'This changes the default model used for all chat notes. Currently, setting models per-note is not supported (but maybe someday!). You can change this default model again at any time using this dialog or the settings.'
 		});
 
-		const notice = new Notice('Loading models…', 0); // Indefinite notice
+		const notice = new Notice('Loading models…', 0);
 
 		try {
 			const apiKey = this.plugin.settings.apiKey;
@@ -31,7 +31,6 @@ export class ModelSelectorModal extends Modal {
 				return;
 			}
 
-			// Use cached models if available
 			let models = await this.ors.getCachedModels(apiKey);
 			if (models.length === 0) {
 				contentEl.createEl('p', { text: 'No models loaded. Check your API key or network connection.' });
@@ -39,7 +38,6 @@ export class ModelSelectorModal extends Modal {
 				return;
 			}
 
-			// Sort models based on the setting
 			models = this.ors.sortModels(models, this.plugin.settings.modelSortOrder as ModelSortOption);
 			const formatted = this.ors.getFormattedModels(models);
 
@@ -52,9 +50,8 @@ export class ModelSelectorModal extends Modal {
 					dd.onChange(async (val) => {
 						this.plugin.settings.defaultModel = val;
 						await this.plugin.saveSettings();
-						// Find the display name for the notice
 						const selectedModelInfo = formatted.find(m => m.id === val);
-						const modelDisplayName = selectedModelInfo ? selectedModelInfo.displayName.split('|')[0].trim() : val; // Extract name before price
+						const modelDisplayName = selectedModelInfo ? selectedModelInfo.displayName.split('|')[0].trim() : val;
 						new Notice(`Default chat model set to "${modelDisplayName}".`);
 						this.close();
 					});
diff --git a/src/OpenRouterService.ts b/src/OpenRouterService.ts
index f9b0547..cff0f49 100644
--- a/src/OpenRouterService.ts
+++ b/src/OpenRouterService.ts
@@ -28,9 +28,6 @@ export interface OpenRouterModel {
     } | null;
 }
 
-/**
- * Defines the available sorting options for models.
- */
 export enum ModelSortOption {
     ALPHABETICAL = 'alphabetical',
     PROMPT_PRICE_ASC = 'prompt_price_asc',
@@ -39,9 +36,6 @@ export enum ModelSortOption {
     COMPLETION_PRICE_DESC = 'completion_price_desc'
 }
 
-/**
- * Represents the formatted information for a model, suitable for display.
- */
 export interface FormattedModelInfo {
     id: string;
     displayName: string;
@@ -58,55 +52,41 @@ export class OpenRouterService {
      * @returns A formatted string representing the price per million tokens (e.g., "$1.50", "free", "<$0.01").
      */
     private formatPricePerMillion(price: string | undefined | null): string {
-        if (price === undefined || price === null) return '?'; // Indicate unknown price
+        if (price === undefined || price === null) return '?';
 
         const numPrice = typeof price === 'string' ? parseFloat(price) : NaN;
 
-        if (isNaN(numPrice)) return '?'; // Indicate invalid price string
+        if (isNaN(numPrice)) return '?';
         if (numPrice === 0) return 'free';
 
         const pricePerMillion = numPrice * 1000000;
 
         let formattedPrice: string;
-        // Format based on magnitude
         if (pricePerMillion < 0.01) {
             formattedPrice = '<0.01';
         } else if (pricePerMillion < 10) {
-            // Use toFixed(2) for prices like $1.50, $0.15 etc.
             formattedPrice = pricePerMillion.toFixed(2);
         } else if (pricePerMillion < 100) {
-            // Use toFixed(1) for prices like $15.5, $99.9
             formattedPrice = pricePerMillion.toFixed(1);
         } else {
-            // Round for prices >= $100
             formattedPrice = Math.round(pricePerMillion).toString();
         }
 
-        // Remove trailing zeros after decimal point if they are redundant (e.g., "1.50" -> "1.5", "2.00" -> "2")
-        // But keep ".0" if it resulted from toFixed(1) e.g. 15.0
+        // Clean up decimal formatting to remove redundant trailing zeros
         if (formattedPrice.includes('.')) {
-             formattedPrice = formattedPrice.replace(/(\.\d*?)0+$/, '$1'); // Remove trailing zeros
-             formattedPrice = formattedPrice.replace(/\.$/, ''); // Remove trailing decimal point if it exists (e.g. "2.")
+             formattedPrice = formattedPrice.replace(/(\.\d*?)0+$/, '$1');
+             formattedPrice = formattedPrice.replace(/\.$/, '');
         }
 
 
         return `$${formattedPrice}`;
     }
 
-    /**
-     * Checks if the model cache is valid.
-     * @returns true if models are cached and the cache hasn't expired.
-     */
     isCacheValid(): boolean {
         return this.availableModels.length > 0 &&
                (Date.now() - this.modelsLastFetched) < this.cacheValidityDuration;
     }
 
-    /**
-     * Checks if a refresh is needed (cache expired) but we still have cached models.
-     * Used to determine if we should trigger a background refresh.
-     * @returns true if we have cached models but they're stale
-     */
     isRefreshNeeded(): boolean {
         return this.availableModels.length > 0 &&
                (Date.now() - this.modelsLastFetched) >= this.cacheValidityDuration;
@@ -118,38 +98,25 @@ export class OpenRouterService {
      * @param apiKey The OpenRouter API key.
      */
     backgroundRefreshIfNeeded(apiKey: string): void {
-        // Only proceed if refresh is needed and we have an API key
         if (!this.isRefreshNeeded() || !apiKey) {
             return;
         }
 
         log.debug('OpenRouterService: Starting background model refresh');
 
-        // Start the refresh in the background without awaiting
         this.fetchModels(apiKey, true)
             .then(models => {
                 log.debug(`OpenRouterService: Background refresh completed, loaded ${models.length} models`);
             })
             .catch(error => {
-                // Just log the error - don't show notices or disturb the user
                 log.error('OpenRouterService: Background refresh failed:', error);
             });
     }
 
-    /**
-     * Gets cached models or fetches them if not available.
-     * @param apiKey The OpenRouter API key.
-     * @returns A promise that resolves to the cached models.
-     */
     async getCachedModels(apiKey: string): Promise<OpenRouterModel[]> {
         return this.fetchModels(apiKey, false);
     }
 
-    /**
-     * Clears the model cache and forces a refresh.
-     * @param apiKey The OpenRouter API key.
-     * @returns A promise that resolves to the newly fetched models.
-     */
     async refreshModels(apiKey: string): Promise<OpenRouterModel[]> {
         return this.fetchModels(apiKey, true);
     }
@@ -161,7 +128,6 @@ export class OpenRouterService {
      * @returns A promise that resolves to an array of models or an empty array in case of error.
      */
     async fetchModels(apiKey: string, forceRefresh: boolean = false): Promise<OpenRouterModel[]> {
-        // Return cached models if available and cache is still valid
         if (!forceRefresh && this.isCacheValid()) {
             log.debug('OpenRouterService: Using cached models');
             return this.availableModels;
@@ -169,7 +135,7 @@ export class OpenRouterService {
 
         if (!apiKey) {
             log.warn('OpenRouter API key is missing.');
-            return []; // Don't show notice, just return empty
+            return [];
         }
 
         try {
@@ -212,22 +178,19 @@ export class OpenRouterService {
     /**
      * Sorts an array of models based on specified criteria.
      * @param models The array of models to sort.
-     * @param sortCriteria The sorting criteria ('alphabetical', 'prompt_price_asc', 'prompt_price_desc',
      * @param sortCriteria The sorting criteria enum value. Defaults to `ModelSortOption.ALPHABETICAL`.
      * @returns The sorted array of models.
      */
     sortModels(models: OpenRouterModel[], sortCriteria: ModelSortOption = ModelSortOption.ALPHABETICAL): OpenRouterModel[] {
         const modelsToSort = [...models];
 
-        // Helper to get a consistent name for sorting
         const getModelName = (model: OpenRouterModel): string =>
             model.name?.toLowerCase() ?? model.id?.toLowerCase() ?? '';
 
-        // Helper to parse price, handling 0, null/undefined, and invalid strings
         const parsePrice = (price: string | undefined | null): number => {
             if (price === undefined || price === null) return Infinity;
             const numPrice = parseFloat(price);
-            // Treat NaN or negative prices (shouldn't happen) as Infinity for sorting
+            // Sort invalid/negative prices last
             return isNaN(numPrice) || numPrice < 0 ? Infinity : numPrice;
         };
 
@@ -236,7 +199,6 @@ export class OpenRouterService {
             const nameB = getModelName(b);
             let comparison = 0;
 
-            // Primary sort based on criteria
             switch (sortCriteria) {
                 case ModelSortOption.PROMPT_PRICE_ASC:
                 case ModelSortOption.PROMPT_PRICE_DESC: {
@@ -264,7 +226,7 @@ export class OpenRouterService {
                     break;
             }
 
-            // Secondary sort: if primary comparison is equal, sort alphabetically
+            // Fallback to alphabetical sorting for ties
             if (comparison === 0 && sortCriteria !== ModelSortOption.ALPHABETICAL) {
                 comparison = nameA.localeCompare(nameB);
             }
@@ -275,16 +237,10 @@ export class OpenRouterService {
         return modelsToSort;
     }
 
-    /**
-     * Formats a list of OpenRouter models for display purposes.
-     * @param models The array of models fetched from the API.
-     * @returns An array of FormattedModelInfo objects.
-     */
     getFormattedModels(models: OpenRouterModel[]): FormattedModelInfo[] {
         return models.map(model => {
-            const modelName = model.name || model.id; // Fallback to ID if name is missing
+            const modelName = model.name || model.id;
 
-            // Handle special cases like free models or auto-routing
             if (model.id === 'openrouter/auto') {
                 return {
                     id: model.id,
@@ -292,12 +248,9 @@ export class OpenRouterService {
                 };
             }
 
-            // Check if pricing info exists and format it
             const promptPriceStr = this.formatPricePerMillion(model.pricing?.prompt);
             const completionPriceStr = this.formatPricePerMillion(model.pricing?.completion);
 
-            // Construct the display name
-            // Use 'free' explicitly if the ID indicates it, otherwise use formatted prices
             if (model.id.includes(':free')) {
                  return {
                      id: model.id,
@@ -328,13 +281,11 @@ export class OpenRouterService {
     ): AsyncGenerator<string> {
         const { apiKey, defaultModel } = settings;
 
-        // Validate settings before proceeding
         if (!apiKey) {
             log.error('OpenRouterService: API key is missing.');
             throw new Error("OpenRouter API key is not set");
         }
 
-        // Check if we should refresh the model cache in the background
         this.backgroundRefreshIfNeeded(apiKey);
         if (!defaultModel) {
             log.error('OpenRouterService: Default model is not set.');
@@ -397,23 +348,17 @@ export class OpenRouterService {
             while (!done) {
                  if (signal.aborted) {
                     log.debug('OpenRouterService: Abort signal detected during stream read.');
-                    // Ensure the reader is cancelled if we break early
                     await reader.cancel('Aborted by signal');
-                    // Throwing here ensures the calling ChatService knows it was aborted
                     throw new DOMException(signal.reason || 'Chat cancelled', 'AbortError');
                  }
 
-                let readResult; // Allow TypeScript to infer the type from the assignment below
+                let readResult;
                 try {
                     readResult = await reader.read();
                     done = readResult.done;
-                    // log.debug('OpenRouterService: Raw stream chunk received:', readResult.value);
                 } catch (readError: any) {
-                     // Catch errors during reader.read() itself
                      log.error('OpenRouterService: Error reading stream chunk:', readError);
-                     // Check if it's an abort error triggered by reader.cancel()
                      if (readError.name === 'AbortError') {
-                         // Already handled by the signal check or cancellation logic
                          return;
                      }
                      throw new Error(`Error reading stream: ${readError.message}`);
@@ -485,7 +430,6 @@ export class OpenRouterService {
         messages: ChatMessage[],
         maxTokens?: number
     ): Promise<string | null> {
-        // Validate settings before proceeding
         if (!apiKey) {
             log.error('OpenRouterService: API key is missing for getChatCompletion.');
             new Notice('OpenRouter API key is not set. Please configure it in the plugin settings.');
@@ -513,7 +457,7 @@ export class OpenRouterService {
                     'Content-Type': 'application/json',
                 },
                 body: JSON.stringify(requestBody),
-                throw: false, // Prevent requestUrl from throwing on non-200 status
+                throw: false,
             });
 
             log.debug('OpenRouterService: Non-stream response status:', response.status);
@@ -535,12 +479,12 @@ export class OpenRouterService {
                 log.error(`OpenRouterService: Error fetching non-stream completion: ${response.status}`, response.text);
                 let errorMessage = `LLM request failed. Status: ${response.status}.`;
                  try {
-                    const errorJson = response.json; // Try parsing error JSON
+                    const errorJson = response.json;
                     errorMessage += ` ${errorJson?.error?.message || response.text || ''}`;
                  } catch {
                     errorMessage += ` ${response.text || 'Could not read error body.'}`;
                  }
-                new Notice(errorMessage.substring(0, 200)); // Limit notice length
+                new Notice(errorMessage.substring(0, 200));
                 return null;
             }
         } catch (error) {
diff --git a/src/SettingsTab.ts b/src/SettingsTab.ts
index 4b74d99..a4cf6fd 100644
--- a/src/SettingsTab.ts
+++ b/src/SettingsTab.ts
@@ -64,26 +64,21 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 			.setName('Model sorting')
 			.setDesc('Choose how to sort the OpenRouter model lists in the dropdowns below.')
 			.addDropdown(dropdown => {
-				// Add options based on the ModelSortOption enum
 				dropdown
 					.addOption(ModelSortOption.ALPHABETICAL, 'Alphabetical')
 					.addOption(ModelSortOption.PROMPT_PRICE_ASC, 'Prompt price: ascending')
 					.addOption(ModelSortOption.PROMPT_PRICE_DESC, 'Prompt price: descending')
 					.addOption(ModelSortOption.COMPLETION_PRICE_ASC, 'Completion price: ascending')
 					.addOption(ModelSortOption.COMPLETION_PRICE_DESC, 'Completion price: descending')
-					// Set the current value from settings
 					.setValue(this.plugin.settings.modelSortOrder)
 					.onChange(async (value) => {
-						// Ensure the value is a valid ModelSortOption before saving
 						if (Object.values(ModelSortOption).includes(value as ModelSortOption)) {
 							this.plugin.settings.modelSortOrder = value as ModelSortOption;
 							await this.plugin.saveSettings();
 							new Notice(`Model sort order set to: ${dropdown.selectEl.selectedOptions[0]?.text || value}`);
-							// Re-populate dropdowns with new sort order
 							this.populateModelDropdowns();
 						} else {
 							log.warn(`SettingsTab: Invalid sort option selected: ${value}`);
-							// Optionally revert dropdown to saved setting or default
 							dropdown.setValue(this.plugin.settings.modelSortOrder);
 						}
 					});
@@ -127,7 +122,7 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 					const trimmedValue = value.trim();
 					this.plugin.settings.chatCommandPhrase = trimmedValue;
 					await this.plugin.saveSettings();
-					this.updateNewNotePathPreview(); // Update preview
+					this.updateNewNotePathPreview();
 				}));
 
 		new Setting(containerEl)
@@ -185,12 +180,12 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 					this.plugin.settings.enableSpacebarDetection = value;
 					await this.plugin.saveSettings();
 					new Notice(`Spacebar command detection ${value ? 'enabled' : 'disabled'}.`);
-					if (spacebarDelaySetting) { // Check if spacebarDelaySetting is initialized
+					if (spacebarDelaySetting) {
 						spacebarDelaySetting.settingEl.toggleClass('snc-hidden', !value);
 					}
 				}));
 
-		spacebarDelaySetting = new Setting(containerEl) // Assign here
+		spacebarDelaySetting = new Setting(containerEl)
 			.setName('Spacebar detection delay')
 			.setDesc('Wait time in seconds before acting after spacebar detection (e.g., 0.5 for half a second).')
 			.addText(text => text
@@ -215,8 +210,7 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 				}
 			});
 
-		// Set initial visibility of the delay setting
-		if (spacebarDelaySetting) { // Check if spacebarDelaySetting is initialized
+		if (spacebarDelaySetting) {
 			spacebarDelaySetting.settingEl.toggleClass('snc-hidden', !this.plugin.settings.enableSpacebarDetection);
 		}
 
@@ -249,13 +243,11 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 					this.plugin.settings.enableArchiveRenameDate = value;
 					await this.plugin.saveSettings();
 					new Notice(`Archive renaming ${value ? 'enabled' : 'disabled'}.`);
-					// Show/hide the date format setting
 					if (dateTimeFormatSetting) {
 						dateTimeFormatSetting.settingEl.toggleClass('snc-hidden', !value);
 					}
 				}));
 
-		// Store the setting instance to control its visibility
 		const dateTimeFormatSetting = new Setting(containerEl)
 			.setName('Date and time format')
 			.setDesc('This uses moment.js for specifying the date and time format to use on the archived note. Default: (YYYY-MM-DD-HH-mm)')
@@ -273,7 +265,6 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 					}
 				}));
 
-		// Set initial visibility based on the toggle state
 		dateTimeFormatSetting.settingEl.toggleClass('snc-hidden', !this.plugin.settings.enableArchiveRenameDate);
 
 		new Setting(containerEl)
@@ -285,7 +276,6 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 					this.plugin.settings.enableArchiveRenameLlm = value;
 					await this.plugin.saveSettings();
 					new Notice(`LLM title renaming ${value ? 'enabled' : 'disabled'}.`);
-					// No need to update description here anymore
 					llmSettingsContainer.toggleClass('snc-hidden', !value);
 				}));
 
@@ -295,7 +285,7 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 			.setName('Note title model')
 			.setDesc('Choose which model will generate the note title. By default, it uses the same model as your chat conversations.')
 			.addDropdown(dropdown => {
-				this.llmModelDropdown = dropdown; // Assign to the class property
+				this.llmModelDropdown = dropdown;
 				dropdown.addOption('', 'Use current chat model');
 				dropdown.setValue(this.plugin.settings.llmRenameModel);
 				dropdown.onChange(async (value) => {
@@ -347,7 +337,6 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 		containerEl.createEl('p', { text: 'Configure how new chat notes are created and where they are placed in your vault.', cls: 'snc-setting-section-description' });
 		this.newNotePreviewEl = containerEl.createEl('p', { cls: 'snc-setting-section-description' });
 
-		// Initial update for the consolidated preview
 		this.updateNewNotePathPreview();
 
 		new Setting(containerEl)
@@ -365,15 +354,14 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 							await this.plugin.saveSettings();
 							new Notice(`New note location set to: ${dropdown.selectEl.selectedOptions[0]?.text || value}`);
 							customFolderSetting.settingEl.toggleClass('snc-hidden', value !== 'custom');
-							this.updateNewNotePathPreview(); // Update the consolidated preview
+							this.updateNewNotePathPreview();
 						} else {
 							log.warn(`SettingsTab: Invalid new note location selected: ${value}`);
-							dropdown.setValue(this.plugin.settings.newNoteLocation); // Revert
+							dropdown.setValue(this.plugin.settings.newNoteLocation);
 						}
 					});
 			});
 
-		// --- Custom Folder Setting (only shown when location is 'custom') ---
 		const customFolderSetting = new Setting(containerEl)
 			.setName('Custom folder')
 			.setDesc(`Which folder should new chat notes be placed in? If the folder doesn't exist then it will get created when the next chat note is created.`)
@@ -385,15 +373,13 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 					if (this.plugin.settings.newNoteCustomFolder !== trimmedValue) {
 						this.plugin.settings.newNoteCustomFolder = trimmedValue;
 						await this.plugin.saveSettings();
-						this.updateNewNotePathPreview(); // Update preview when custom folder changes
+						this.updateNewNotePathPreview();
 					}
 				}));
 
-		// Initially hide the custom folder setting
 		customFolderSetting.settingEl.toggleClass('snc-hidden', this.plugin.settings.newNoteLocation !== 'custom');
 
-		// --- New Note Date & Time ---
-		new Setting(containerEl) // Store the setting instance
+		new Setting(containerEl)
 			.setName('Optional date & time')
 			.setDesc('Uses moment.js format for date/time in the title. Leave empty if no date/time is desired. Default: (YYYY-MM-DD-HH-mm)')
 			.addText(text => { text
@@ -406,8 +392,7 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 				});
 			});
 
-		// --- New Note Title Prefix ---
-		new Setting(containerEl) // Store the setting instance
+		new Setting(containerEl)
 		.setName('Optional prefix')
 		.setDesc('Text to add before the date/time in the new chat note title.')
 		.addText(text => { text
@@ -420,8 +405,7 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 			});
 		});
 
-		// --- New Note Title Suffix ---
-		new Setting(containerEl) // Store the setting instance
+		new Setting(containerEl)
 			.setName('Optional suffix')
 			.setDesc('Text to add after the date/time in the new chat note title.')
 			.addText(text => { text
@@ -437,7 +421,6 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 		// Initial update for the consolidated preview
 		this.updateNewNotePathPreview();
 
-		// Fetch models and populate dropdowns on display (handles missing API key internally)
 		this.fetchAndStoreModels(false);
 		new Setting(containerEl).setName('Logging').setHeading();
 		containerEl.createEl('p', {
@@ -457,7 +440,7 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 					await this.plugin.saveSettings();
 					initializeLogger(this.plugin.settings); // Update logger immediately
 					if (loggingLevelSetting) {
-						loggingLevelSetting.settingEl.toggleClass('snc-hidden', !value); // Show/hide level dropdown
+						loggingLevelSetting.settingEl.toggleClass('snc-hidden', !value);
 					}
 					new Notice(`Logging ${value ? 'enabled' : 'disabled'}.`);
 				}));
@@ -476,16 +459,15 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 						if (Object.values(LogLevel).includes(value as LogLevel)) {
 							this.plugin.settings.logLevel = value as LogLevel;
 							await this.plugin.saveSettings();
-							initializeLogger(this.plugin.settings); // Update logger immediately
+							initializeLogger(this.plugin.settings);
 							new Notice(`Log level set to ${value}`);
 						} else {
 							log.warn(`SettingsTab: Invalid log level selected: ${value}`);
-							dropdown.setValue(this.plugin.settings.logLevel); // Revert
+							dropdown.setValue(this.plugin.settings.logLevel);
 						}
 					});
 			});
 
-		// Set initial visibility of the logging level dropdown
 		if (loggingLevelSetting) {
 			loggingLevelSetting.settingEl.toggleClass('snc-hidden', !this.plugin.settings.enableLogging);
 		}
@@ -516,7 +498,7 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 		dropdown.selectEl.empty();
 
 		if (!this.plugin.settings.apiKey) {
-			dropdown.addOption('', 'Enter API key to load models'); // Assuming noApiKeyText was 'Enter API Key to load models'
+			dropdown.addOption('', 'Enter API key to load models');
 			dropdown.setDisabled(true);
 			dropdown.setValue('');
 			return;
@@ -537,13 +519,11 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 		});
 
 		const savedModel = this.plugin.settings[settingKey] as string;
-		// Check if the current or saved model ID exists in the formatted list
 		const valueToSelect = formattedModels.some(m => m.id === currentSelectedValue) ? currentSelectedValue : savedModel;
 
 		if (valueToSelect && formattedModels.some(m => m.id === valueToSelect)) {
 			dropdown.setValue(valueToSelect);
 		} else {
-			// If the saved model is no longer valid or wasn't set, default to empty/placeholder
 			dropdown.setValue('');
 		}
 	}
@@ -570,7 +550,6 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 
 		const filename = `${prefix}${formattedDate}${suffix}.md`;
 
-		// Basic check for potentially invalid characters in filename
 		if (/[\\/:]/.test(filename)) {
 			log.warn("SettingsTab: Generated filename contains potentially invalid characters:", filename);
 			return { filename: 'Invalid characters in filename', error: true };
@@ -618,7 +597,6 @@ export class SimpleNoteChatSettingsTab extends PluginSettingTab {
 					previewText = `Preview: ${filename} (created in the folder of the currently active note, or root folder if none)`;
 					break;
 			}
-			// Basic check for invalid characters in folder path (relevant for custom/archive)
 			if ((location === 'custom' || location === 'archive') && /[\\:*?"<>|]/.test(folderPath)) {
 				previewText = `Preview: Invalid characters in folder path: ${folderPath}`;
 				previewClass = 'snc-preview-error';
diff --git a/src/main.ts b/src/main.ts
index 253f05a..5b3a2ed 100644
--- a/src/main.ts
+++ b/src/main.ts
@@ -37,7 +37,7 @@ export default class SimpleNoteChatPlugin extends Plugin {
 	async onload() {
 		log.debug('Loading Simple Note Chat plugin');
 		await this.loadSettings();
-		initializeLogger(this.settings); // Initialize logger with loaded settings
+		initializeLogger(this.settings);
 
 		this.updateCommandMap();
 		this.lastSettingsHash = this.getSettingsHash();
@@ -72,7 +72,6 @@ export default class SimpleNoteChatPlugin extends Plugin {
 			}
 		}));
 
-		// Check for active markdown view on plugin load
 		const currentLeaf = this.app.workspace.activeLeaf;
 		if (currentLeaf?.view instanceof MarkdownView) {
 			const view = currentLeaf.view;
@@ -106,16 +105,13 @@ export default class SimpleNoteChatPlugin extends Plugin {
 						targetFolder = this.settings.archiveFolderName;
 					}
 
-					// Normalize the targetFolder path
 					if (targetFolder && targetFolder !== '/') {
 						targetFolder = normalizePath(targetFolder);
-					} else if (targetFolder === '') { // Handle case where custom path might be empty
-						targetFolder = '/'; // Default to root if empty
+					} else if (targetFolder === '') {
+						targetFolder = '/';
 					}
 
 
-					// Ensure target folder exists
-					// For root, no check/creation is needed. For others, check and create.
 					if (targetFolder !== '/') {
 						const folderExists = this.app.vault.getAbstractFileByPath(targetFolder) !== null;
 						if (!folderExists) {
@@ -125,12 +121,11 @@ export default class SimpleNoteChatPlugin extends Plugin {
 							} catch (folderError) {
 								log.error(`Failed to create target folder "${targetFolder}":`, folderError);
 								new Notice(`Failed to create folder "${targetFolder}". Using vault root.`);
-								targetFolder = '/'; // Fallback to root on folder creation error
+								targetFolder = '/';
 							}
 						}
 					}
 
-					// Construct title using prefix, format, and suffix
 					const formattedDate = moment().format(this.settings.newNoteTitleFormat || DEFAULT_NN_TITLE_FORMAT);
 					const prefix = this.settings.newNoteTitlePrefix || '';
 					const suffix = this.settings.newNoteTitleSuffix || '';
@@ -140,7 +135,7 @@ export default class SimpleNoteChatPlugin extends Plugin {
 					const availablePath = await this.fileSystemService.findAvailablePath(targetFolder, baseFilename);
 
 					const newFile = await this.app.vault.create(availablePath, '');
-					await this.app.workspace.openLinkText(newFile.path, '', true); // Ensure leaf is open before notice
+					await this.app.workspace.openLinkText(newFile.path, '', true);
 					new Notice(`Created new chat note: ${newFile.basename}`);
 
 				} catch (error) {
@@ -160,7 +155,7 @@ export default class SimpleNoteChatPlugin extends Plugin {
 					return;
 				}
 				log.debug(`Triggering chat completion via hotkey for file: ${file.path}`);
-				const cursor = editor.getCursor(); // Get cursor position
+				const cursor = editor.getCursor();
 				this.chatService.startChat(editor, file, this.settings, cursor)
 					.catch((error: Error) => {
 						log.error("Error starting chat from hotkey:", error);
@@ -175,14 +170,13 @@ export default class SimpleNoteChatPlugin extends Plugin {
 			checkCallback: (checking: boolean) => {
 				const activeFile = this.app.workspace.getActiveFile();
 				if (!activeFile) {
-					return false; // No active file to archive
+					return false;
 				}
 
 				if (checking) {
-					return true; // Command is available if there's an active file
+					return true;
 				}
 
-				// Execute the archive logic - moveFileToArchive handles notifications
 				this.fileSystemService.moveFileToArchive(
 					activeFile,
 					this.settings.archiveFolderName,
@@ -205,7 +199,6 @@ export default class SimpleNoteChatPlugin extends Plugin {
 
 	onunload() {
 		log.debug('Unloading Simple Note Chat plugin');
-		// Ensure the listener is removed when the plugin unloads
 		this.unregisterScopedKeyDownHandler();
 	}
 
@@ -214,7 +207,6 @@ export default class SimpleNoteChatPlugin extends Plugin {
 			this.activeEditorKeyDownTarget.removeEventListener('keydown', this.boundKeyDownHandler);
 			log.debug("Unregistered scoped keydown handler");
 		}
-		// Clear all pending spacebar timeouts when unregistering
 		this.spacebarCommandTimeoutIds.forEach(timeoutId => clearTimeout(timeoutId));
 		this.spacebarCommandTimeoutIds.clear();
 
@@ -226,21 +218,19 @@ export default class SimpleNoteChatPlugin extends Plugin {
 
 	async loadSettings() {
 		this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
-		this.settings.chatSeparator = CHAT_SEPARATOR; // Ensure the constant is always used
+		this.settings.chatSeparator = CHAT_SEPARATOR;
 	}
 
 	async saveSettings() {
 		await this.saveData(this.settings);
 
-		// Update command map when settings change
 		this.updateCommandMap();
-		initializeLogger(this.settings); // Re-initialize logger with new settings
+		initializeLogger(this.settings);
 		this.lastSettingsHash = this.getSettingsHash();
 	}
 
 	/**
-	 * Creates a hash string representing the current command phrase settings
-	 * to detect when settings change.
+	 * Creates a hash to detect command phrase setting changes.
 	 */
 	private getSettingsHash(): string {
 		return [
@@ -251,9 +241,6 @@ export default class SimpleNoteChatPlugin extends Plugin {
 		].join('|');
 	}
 
-	/**
-	 * Updates the command map based on current settings.
-	 */
 	private updateCommandMap() {
 		this.commandMap = {};
 
@@ -277,20 +264,16 @@ export default class SimpleNoteChatPlugin extends Plugin {
 
 	/**
 	 * Handles keydown events for stream cancellation and command triggers.
-	 * @param view The MarkdownView instance where the event occurred.
-	 * @param evt The keyboard event.
 	 */
 	private handleKeyDown(view: MarkdownView, evt: KeyboardEvent): void {
 		const file = view.file;
 
-		// 1. Basic checks
 		if (!file) {
 			log.debug("Keydown ignored: No file associated with the view.");
 			return;
 		}
 		const filePath = file.path;
 
-		// Refined Spacebar Timeout Clearing (Requirement 6)
 		const existingTimeoutId = this.spacebarCommandTimeoutIds.get(filePath);
 		if (existingTimeoutId && evt.key !== ' ') {
 			clearTimeout(existingTimeoutId);
@@ -298,12 +281,10 @@ export default class SimpleNoteChatPlugin extends Plugin {
 			log.debug(`Cleared spacebar command timeout for ${filePath} due to subsequent non-space key press: ${evt.key}`);
 		}
 
-		// Handle Escape key
 		if (this.handleEscapeKey(view, evt)) {
-			return; // Escape was handled
+			return;
 		}
 
-		// If a stream is active, ignore further processing for Enter and Space
 		if (this.chatService.isStreamActive(filePath)) {
 			if (evt.key === 'Enter' || evt.key === ' ') {
 				log.debug(`${evt.key} key ignored: Stream active for ${filePath}.`);
@@ -311,17 +292,13 @@ export default class SimpleNoteChatPlugin extends Plugin {
 			}
 		}
 
-		// Implement Early Exit for Non-Command Keys
 		const isEnterKey = evt.key === 'Enter';
 		const isSpaceKeyForCommand = evt.key === ' ' && this.settings.enableSpacebarDetection;
 
 		if (!isEnterKey && !isSpaceKeyForCommand) {
-			return; // Most keystrokes exit here
+			return;
 		}
 
-		// At this point, only Enter or Space (if enabled) will proceed.
-
-		// Dispatch to specific key handlers
 		if (isEnterKey) {
 			this.handleEnterKey(view, evt);
 			return;
@@ -334,16 +311,13 @@ export default class SimpleNoteChatPlugin extends Plugin {
 	}
 
 	/**
-	 * Handles the Escape key press, primarily for stream cancellation.
-	 * @param view The MarkdownView instance.
-	 * @param evt The keyboard event.
-	 * @returns True if the event was handled, false otherwise.
+	 * Handles Escape key for stream cancellation.
 	 */
 	private handleEscapeKey(view: MarkdownView, evt: KeyboardEvent): boolean {
 		if (evt.key !== 'Escape') return false;
 
 		const editor = view.editor;
-		const file = view.file; // Already checked for null in handleKeyDown
+		const file = view.file;
 		const filePath = file!.path;
 
 		log.debug(`Key: Escape, File: ${filePath}`);
@@ -355,24 +329,21 @@ export default class SimpleNoteChatPlugin extends Plugin {
 			return true;
 		} else if (isActive) {
 			log.debug("Stream cancellation via Escape failed or no stream to cancel.");
-			return true; // Still handled as Escape's purpose here is stream-related
+			return true;
 		}
-		return false; // No active stream to cancel
+		return false;
 	}
 
 	/**
-	 * Handles the Enter key press for command execution.
-	 * @param view The MarkdownView instance.
-	 * @param evt The keyboard event.
+	 * Handles Enter key for command execution.
 	 */
 	private handleEnterKey(view: MarkdownView, evt: KeyboardEvent): void {
 		const editor = view.editor;
-		const file = view.file!; // Already checked for null in handleKeyDown
+		const file = view.file!
 		const filePath = file.path;
 
 		log.debug(`Key: Enter, File: ${filePath}`);
 
-		// Defer Settings Hash Check (Requirement 5)
 		const currentSettingsHash = this.getSettingsHash();
 		if (this.lastSettingsHash !== currentSettingsHash) {
 			this.updateCommandMap();
@@ -397,19 +368,15 @@ export default class SimpleNoteChatPlugin extends Plugin {
 	}
 
 	/**
-	 * Handles the Space key press for command execution (if enabled).
-	 * @param view The MarkdownView instance.
-	 * @param evt The keyboard event.
+	 * Handles Space key for delayed command execution when spacebar detection is enabled.
 	 */
 	private handleSpaceKey(view: MarkdownView, evt: KeyboardEvent): void {
 		const editor = view.editor;
-		const file = view.file!; // Already checked for null in handleKeyDown
+		const file = view.file!
 		const filePath = file.path;
 
 		log.debug(`Key: Space, File: ${filePath}, Spacebar detection enabled.`);
-		// Space key itself should be typed. Do not preventDefault/stopPropagation here.
 
-		// Defer Settings Hash Check (Requirement 5)
 		const currentSettingsHash = this.getSettingsHash();
 		if (this.lastSettingsHash !== currentSettingsHash) {
 			this.updateCommandMap();
@@ -417,14 +384,13 @@ export default class SimpleNoteChatPlugin extends Plugin {
 			log.debug("Command map updated due to settings change (triggered by Space).");
 		}
 
-		// Clear any existing timeout for this specific file path before setting a new one
 		const oldTimeoutId = this.spacebarCommandTimeoutIds.get(filePath);
 		if (oldTimeoutId) {
 			clearTimeout(oldTimeoutId);
 			log.debug(`Cleared previous spacebar timeout for ${filePath} due to new space press.`);
 		}
 
-		const triggerCursor = editor.getCursor(); // Store cursor position at the time space was pressed
+		const triggerCursor = editor.getCursor();
 
 		const newTimeoutId = window.setTimeout(() => {
 			this.spacebarCommandTimeoutIds.delete(filePath);
diff --git a/src/types.ts b/src/types.ts
index 3baa9f9..0652102 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -12,18 +12,15 @@ export interface PluginSettings {
   apiKey: string;
   defaultModel: string;
   archiveFolderName: string;
-  // Settings for the 'New Note' command
   newNoteLocation: 'current' | 'archive' | 'custom';
   newNoteCustomFolder: string;
   newNoteTitleFormat: string;
-  // Settings for the 'Archive' command
   enableArchiveRenameDate: boolean;
   archiveRenameDateFormat: string;
   enableArchiveRenameLlm: boolean;
   llmRenameWordLimit: number;
   llmRenameIncludeEmojis: boolean;
   llmRenameModel: string; // Stores the ID of the model to use for titling
-  // General settings
   newNoteTitlePrefix: string;
   newNoteTitleSuffix: string;
   modelSortOrder: string;
@@ -33,11 +30,8 @@ export interface PluginSettings {
   modelCommandPhrase: string;
   chatSeparator: string;
 
-  // Behavior Settings
   enableSpacebarDetection: boolean;
   spacebarDetectionDelay: number;
-
-  // Logging Settings
   enableLogging: boolean;
   logLevel: LogLevel;
 }
@@ -46,18 +40,15 @@ export const DEFAULT_SETTINGS: PluginSettings = {
   apiKey: '',
   defaultModel: 'openrouter/auto',
   archiveFolderName: DEFAULT_ARCHIVE_FOLDER,
-  // New Note settings defaults
   newNoteLocation: 'archive',
   newNoteCustomFolder: '',
   newNoteTitleFormat: DEFAULT_NN_TITLE_FORMAT,
-  // Archive settings defaults
   enableArchiveRenameDate: false,
   archiveRenameDateFormat: DEFAULT_NN_TITLE_FORMAT,
   enableArchiveRenameLlm: false,
   llmRenameWordLimit: 5,
   llmRenameIncludeEmojis: false,
-  llmRenameModel: '',
-  // General settings defaults
+  llmRenameModel: ''
   newNoteTitlePrefix: '',
   newNoteTitleSuffix: '',
   modelSortOrder: 'alphabetical',
@@ -66,10 +57,8 @@ export const DEFAULT_SETTINGS: PluginSettings = {
   newChatCommandPhrase: '',
   modelCommandPhrase: '',
   chatSeparator: CHAT_SEPARATOR,
-  // Behavior Settings defaults
   enableSpacebarDetection: false,
-  spacebarDetectionDelay: 0.5,
-  // Logging Defaults
+  spacebarDetectionDelay: 0.5
   enableLogging: false,
   logLevel: LogLevel.ERROR,
 };
diff --git a/src/utils/logger.ts b/src/utils/logger.ts
index a97f238..ed47cab 100644
--- a/src/utils/logger.ts
+++ b/src/utils/logger.ts
@@ -1,15 +1,12 @@
 import { PluginSettings, LogLevel } from '../types';
 
 /**
- * Simple logger utility.
- * Logging behavior is controlled by plugin settings.
+ * Logger utility with configurable levels controlled by plugin settings.
  */
 
-// Module-level variables to store current logging settings
 let loggingEnabled = false;
 let currentLogLevel = LogLevel.ERROR;
 
-// Map LogLevel enum to numeric values for easier comparison
 const LogLevelValue: { [key in LogLevel]: number } = {
 	[LogLevel.ERROR]: 1,
 	[LogLevel.WARN]: 2,
@@ -18,14 +15,11 @@ const LogLevelValue: { [key in LogLevel]: number } = {
 };
 
 /**
- * Initializes or updates the logger settings.
- * Called by the main plugin on load and when settings change.
- * @param settings The current plugin settings.
+ * Initializes logger with current plugin settings.
  */
 export const initializeLogger = (settings: PluginSettings): void => {
 	loggingEnabled = settings.enableLogging;
 	currentLogLevel = settings.logLevel;
-	// Log initialization status itself if INFO level is enabled
 	if (loggingEnabled && LogLevelValue[currentLogLevel] >= LogLevelValue[LogLevel.INFO]) {
 		console.info(`Logger initialized. Logging enabled: ${loggingEnabled}, Level: ${currentLogLevel}`);
 	}
@@ -48,7 +42,6 @@ export const log = {
 		}
 	},
 	error: (message: string, ...args: any[]): void => {
-		// Errors are logged if logging is enabled, regardless of level (minimum level is ERROR)
 		if (loggingEnabled && LogLevelValue[currentLogLevel] >= LogLevelValue[LogLevel.ERROR]) {
 			console.error(`[ERROR] ${message}`, ...args);
 		}
